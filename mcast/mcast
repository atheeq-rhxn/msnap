#!/usr/bin/env bash
# This script was generated by bashly 1.3.5 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  set -euo pipefail

  output_dir="${args[--output]:-${ini[output_dir]:-$HOME/Videos/Screencasts}}"
  filename_pattern="${args[--filename]:-${ini[filename_pattern]:-%Y%m%d%H%M%S.mp4}}"
  backend="${args[--backend]:-${ini[backend]:-wf-recorder}}"
  toggle_mode="${args[--toggle]:-}"

  command -v "$backend" >/dev/null || { echo "Error: $backend not installed"; exit 1; }

  recording_pid_file="/tmp/mcast.pid"
  recording_filepath_file="/tmp/mcast.filepath"

  build_cmd() {
    local geometry=""
    if [[ ${args[--geometry]:-} ]]; then
      geometry="${args[--geometry]}"
    elif [[ ${args[--region]:-} ]]; then
      geometry="$(slurp -d)" || { echo "Error: Failed to select region"; exit 1; }
    fi

    case "$backend" in
      wf-recorder)
        if [[ -n "$geometry" ]]; then
          cmd="$backend -g \"$geometry\" -f \"$filepath\""
        else
          cmd="$backend -f \"$filepath\""
        fi
        ;;
      wl-screenrec)
        if [[ -n "$geometry" ]]; then
          cmd="$backend -g \"$geometry\" -f \"$filepath\""
        else
          cmd="$backend -f \"$filepath\""
        fi
        ;;
      gpu-screen-recorder)
        if [[ -n "$geometry" ]]; then
          local x y w h
          IFS=',x ' read -r x y w h <<< "$geometry"
          local region_arg="-region ${w}x${h}+${x}+${y}"
          local capture_type="-w region"
          cmd="$backend $capture_type $region_arg -f 60 -o \"$filepath\""
        else
          cmd="$backend -w screen -f 60 -o \"$filepath\""
        fi
        ;;
      *)
        echo "Error: Unknown backend $backend"
        exit 1
        ;;
    esac
  }

  if [[ -n "$toggle_mode" ]]; then
    if [[ -f "$recording_pid_file" ]] && kill -0 "$(<"$recording_pid_file")" 2>/dev/null; then
      kill "$(<"$recording_pid_file")"
      rm -f "$recording_pid_file"
      if [[ -f "$recording_filepath_file" ]]; then
        filepath=$(<"$recording_filepath_file")
        rm -f "$recording_filepath_file"
        notify-send "Recording saved" "Recording saved in <i>${filepath}</i>." -a mcast
      fi
    else
      filename="$(date +"$filename_pattern")"
      filepath="$output_dir/$filename"
      mkdir -p "$output_dir"
      echo "$filepath" > "$recording_filepath_file"

      build_cmd
      eval "$cmd > /dev/null 2>&1 &"
      echo $! > "$recording_pid_file"
    fi
  else
    filename="$(date +"$filename_pattern")"
    filepath="$output_dir/$filename"
    mkdir -p "$output_dir"

    build_cmd
    eval "$cmd"
    notify-send "Recording saved" "Recording saved in <i>${filepath}</i>." -a mcast
  fi

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
mcast_usage() {
  printf "mcast - Mango cast cli tool\n\n"

  printf "%s\n" "Usage:"
  printf "  mcast [OPTIONS]\n"
  printf "  mcast --help | -h\n"
  printf "  mcast --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--region, -r"
    printf "    Record selected region (interactive selection)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--geometry, -g SPEC"
    printf "    Record region with direct geometry in \"x,y wxh\" format\n"
    echo

    # :flag.usage
    printf "  %s\n" "--backend, -b RECORDER"
    printf "    Screen recorder backend to use\n"
    printf "    %s\n" "Allowed: wf-recorder, wl-screenrec, gpu-screen-recorder"
    echo

    # :flag.usage
    printf "  %s\n" "--toggle, -t"
    printf "    Toggle recording on/off\n"
    echo

    # :flag.usage
    printf "  %s\n" "--output, -o DIRECTORY"
    printf "    Output directory for recording\n"
    echo

    # :flag.usage
    printf "  %s\n" "--filename, -f NAME"
    printf "    Output filename for recording\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/ini.sh
ini_load() {
  unset ini
  declare -gA ini

  local ini_file="$1"

  local section=""
  local key=""
  local value=""
  local section_regex="^\[(.+)\]"
  local key_regex="^([^ =]+) *= *(.*) *$"
  local comment_regex="^;"

  while IFS= read -r line; do
    if [[ $line =~ $comment_regex ]]; then
      continue
    elif [[ $line =~ $section_regex ]]; then
      section="${BASH_REMATCH[1]}."
    elif [[ $line =~ $key_regex ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      [[ $value == *\$* ]] && eval "value=\"$value\""
      ini["${section}${key}"]="$value"
    fi
  done <"$ini_file"
}

ini_save() {
  declare -gA ini

  local ini_file="$1"

  local current_section=""
  local has_free_keys=false

  rm -f "$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] && continue
    has_free_keys=true
    value="${ini[$key]}"
    echo "$key = $value" >>"$ini_file"
  done

  [[ "${has_free_keys}" == "true" ]] && echo >>"$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] || continue
    value="${ini[$key]}"
    IFS="." read -r section_name key_name <<<"$key"

    if [[ "$current_section" != "$section_name" ]]; then
      [[ $current_section ]] && echo >>"$ini_file"
      echo "[$section_name]" >>"$ini_file"
      current_section="$section_name"
    fi

    echo "$key_name = $value" >>"$ini_file"
  done
}

ini_show() {
  declare -gA ini

  for key in $(ini_keys); do
    echo "$key = ${ini[$key]}"
  done
}

ini_keys() {
  declare -gA ini

  local keys=("${!ini[@]}")
  for a in "${keys[@]}"; do echo "$a"; done | sort
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        mcast_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --region | -r)

        # :flag.case_no_arg
        args['--region']=1
        shift
        ;;

      # :flag.case
      --geometry | -g)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--geometry']="$2"
          shift
          shift
        else
          printf "%s\n" "--geometry requires an argument: --geometry, -g SPEC" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --backend | -b)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--backend']="$2"
          shift
          shift
        else
          printf "%s\n" "--backend requires an argument: --backend, -b RECORDER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --toggle | -t)

        # :flag.case_no_arg
        args['--toggle']=1
        shift
        ;;

      # :flag.case
      --output | -o)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--output']="$2"
          shift
          shift
        else
          printf "%s\n" "--output requires an argument: --output, -o DIRECTORY" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --filename | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--filename']="$2"
          shift
          shift
        else
          printf "%s\n" "--filename requires an argument: --filename, -f NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.whitelist_filter
  if [[ ${args['--backend']:-} ]] && [[ ! ${args['--backend']:-} =~ ^(wf-recorder|wl-screenrec|gpu-screen-recorder)$ ]]; then
    printf "%s\n" "--backend must be one of: wf-recorder, wl-screenrec, gpu-screen-recorder" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

  # src/initialize.sh
  config_dir="$HOME/.config/msnap"
  config_file="$config_dir/mcast.conf"
  if [[ ! -f "$config_file" ]]; then
    mkdir -p "$config_dir"
    cp "./mcast.conf" "$config_file"
  fi
  CONFIG_FILE="$config_file"
  ini_load "$config_file"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
