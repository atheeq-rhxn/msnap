#!/usr/bin/env bash
# This script was generated by bashly 1.3.5 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  output_dir="${args[--output]:-${ini[output_dir]:-${XDG_VIDEOS_DIR:-$HOME/Videos}/Screencasts}}"
  filename_pattern="${args[--filename]:-${ini[filename_pattern]:-%Y%m%d%H%M%S.mp4}}"
  toggle_mode="${args[--toggle]:-}"

  recording_pid_file="/tmp/mcast.pid"
  recording_filepath_file="/tmp/mcast.filepath"

  build_cmd() {
    local geometry=""
    if [[ ${args[--geometry]:-} ]]; then
      geometry="${args[--geometry]}"
    elif [[ ${args[--region]:-} ]]; then
      geometry="$(slurp -d)" || { echo "Error: Failed to select region" >&2; exit 1; }
    fi

    cmd=(gpu-screen-recorder)

    if [[ -n "$geometry" ]]; then
      local x y w h
      IFS=',x ' read -r x y w h <<< "$geometry"
      cmd+=(-w region -region "${w}x${h}+${x}+${y}")
    else
      cmd+=(-w screen)
    fi

    if [[ ${args[--audio]:-} && ${args[--mic]:-} ]]; then
      cmd+=(-a "${args[--audio-device]:-default_output}|${args[--mic-device]:-default_input}")
    elif [[ ${args[--audio]:-} ]]; then
      cmd+=(-a "${args[--audio-device]:-default_output}")
    elif [[ ${args[--mic]:-} ]]; then
      cmd+=(-a "${args[--mic-device]:-default_input}")
    fi

    cmd+=(-o "$filepath")
  }

  if [[ -n "$toggle_mode" ]]; then
    if [[ -f "$recording_pid_file" ]]; then
      pid=$(<"$recording_pid_file")
      if kill -0 "$pid" 2>/dev/null; then
        kill -2 "$pid"
      fi
      rm -f "$recording_pid_file"
      if [[ -f "$recording_filepath_file" ]]; then
        filepath=$(<"$recording_filepath_file")
        rm -f "$recording_filepath_file"
        notify-send "Recording saved" "Recording saved in <i>${filepath}</i>." -a mcast
      fi
    else
      filename="$(date +"$filename_pattern")"
      filepath="$output_dir/$filename"
      mkdir -p "$output_dir"
      echo "$filepath" > "$recording_filepath_file"

      build_cmd
      "${cmd[@]}" > /dev/null 2>&1 &
      echo $! > "$recording_pid_file"
    fi
  else
    filename="$(date +"$filename_pattern")"
    filepath="$output_dir/$filename"
    mkdir -p "$output_dir"

    build_cmd
    "${cmd[@]}"
    notify-send "Recording saved" "Recording saved in <i>${filepath}</i>." -a mcast
  fi
}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
mcast_usage() {
  printf "mcast - Mango cast cli tool\n\n"

  printf "%s\n" "Usage:"
  printf "  mcast [OPTIONS]\n"
  printf "  mcast --help | -h\n"
  printf "  mcast --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--region, -r"
    printf "    Record selected region (interactive selection)\n"
    printf "    %s\n" "Conflicts: --geometry"
    echo

    # :flag.usage
    printf "  %s\n" "--geometry, -g X,Y WXH"
    printf "    Record region with direct geometry\n"
    printf "    %s\n" "Conflicts: --region"
    echo

    # :flag.usage
    printf "  %s\n" "--toggle, -t"
    printf "    Toggle recording on/off\n"
    echo

    # :flag.usage
    printf "  %s\n" "--output, -o DIRECTORY"
    printf "    Output directory for recording\n"
    echo

    # :flag.usage
    printf "  %s\n" "--filename, -f NAME"
    printf "    Output filename for recording\n"
    echo

    # :flag.usage
    printf "  %s\n" "--audio, -a"
    printf "    Record system audio\n"
    echo

    # :flag.usage
    printf "  %s\n" "--mic, -m"
    printf "    Record microphone\n"
    echo

    # :flag.usage
    printf "  %s\n" "--audio-device, -A DEVICE"
    printf "    System audio device (default - default_output)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--mic-device, -M DEVICE"
    printf "    Microphone device (default - default_input)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/ini.sh
ini_load() {
  unset ini
  declare -gA ini

  local ini_file="$1"

  local section=""
  local key=""
  local value=""
  local section_regex="^\[(.+)\]"
  local key_regex="^([^ =]+) *= *(.*) *$"
  local comment_regex="^;"

  while IFS= read -r line; do
    if [[ $line =~ $comment_regex ]]; then
      continue
    elif [[ $line =~ $section_regex ]]; then
      section="${BASH_REMATCH[1]}."
    elif [[ $line =~ $key_regex ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      [[ $value == *\$* ]] && eval "value=\"$value\""
      ini["${section}${key}"]="$value"
    fi
  done <"$ini_file"
}

ini_save() {
  declare -gA ini

  local ini_file="$1"

  local current_section=""
  local has_free_keys=false

  rm -f "$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] && continue
    has_free_keys=true
    value="${ini[$key]}"
    echo "$key = $value" >>"$ini_file"
  done

  [[ "${has_free_keys}" == "true" ]] && echo >>"$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] || continue
    value="${ini[$key]}"
    IFS="." read -r section_name key_name <<<"$key"

    if [[ "$current_section" != "$section_name" ]]; then
      [[ $current_section ]] && echo >>"$ini_file"
      echo "[$section_name]" >>"$ini_file"
      current_section="$section_name"
    fi

    echo "$key_name = $value" >>"$ini_file"
  done
}

ini_show() {
  declare -gA ini

  for key in $(ini_keys); do
    echo "$key = ${ini[$key]}"
  done
}

ini_keys() {
  declare -gA ini

  local keys=("${!ini[@]}")
  for a in "${keys[@]}"; do echo "$a"; done | sort
}

# src/lib/validate_geometry_format.sh
validate_geometry_format() {
  local input="$1"

  # Pattern: X,Y WxH where X, Y, W, H are non-negative integers
  if [[ ! "$input" =~ ^[0-9]+,[0-9]+\ [0-9]+x[0-9]+$ ]]; then
    echo "invalid format: Expected 'X,Y WxH' (e.g., '100,200 800x600')"
  fi
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        mcast_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v gpu-screen-recorder >/dev/null 2>&1; then
    printf "missing dependency: gpu-screen-recorder\n" >&2
    missing_deps=1
  else
    deps['gpu-screen-recorder']="$(command -v gpu-screen-recorder | head -n1)"
  fi

  # :dependency.filter
  if ! command -v slurp >/dev/null 2>&1; then
    printf "missing dependency: slurp\n" >&2
    missing_deps=1
  else
    deps['slurp']="$(command -v slurp | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --region | -r)
        # :flag.conflicts
        if [[ -n "${args['--geometry']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--geometry" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--region']=1
        shift
        ;;

      # :flag.case
      --geometry | -g)
        # :flag.conflicts
        if [[ -n "${args['--region']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--region" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--geometry']="$2"
          shift
          shift
        else
          printf "%s\n" "--geometry requires an argument: --geometry, -g X,Y WXH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --toggle | -t)

        # :flag.case_no_arg
        args['--toggle']=1
        shift
        ;;

      # :flag.case
      --output | -o)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--output']="$2"
          shift
          shift
        else
          printf "%s\n" "--output requires an argument: --output, -o DIRECTORY" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --filename | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--filename']="$2"
          shift
          shift
        else
          printf "%s\n" "--filename requires an argument: --filename, -f NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --audio | -a)

        # :flag.case_no_arg
        args['--audio']=1
        shift
        ;;

      # :flag.case
      --mic | -m)

        # :flag.case_no_arg
        args['--mic']=1
        shift
        ;;

      # :flag.case
      --audio-device | -A)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--audio-device']="$2"
          shift
          shift
        else
          printf "%s\n" "--audio-device requires an argument: --audio-device, -A DEVICE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --mic-device | -M)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--mic-device']="$2"
          shift
          shift
        else
          printf "%s\n" "--mic-device requires an argument: --mic-device, -M DEVICE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.validations
  # :flag.validations
  if [[ -v args['--geometry'] ]]; then
    validation_output="$(validate_geometry_format "${args['--geometry']:-}")"
    if [[ -n "${validation_output}" ]]; then
      printf "validation error in %s:\n%s\n" "--geometry, -g X,Y WXH" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

  # src/initialize.sh
  config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/msnap"
  config_file="$config_dir/mcast.conf"
  if [[ ! -f "$config_file" ]]; then
    mkdir -p "$config_dir"
    cp "./mcast.conf" "$config_file"
  fi
  CONFIG_FILE="$config_file"
  ini_load "$config_file"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
