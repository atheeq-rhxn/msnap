#!/usr/bin/env bash
# This script was generated by bashly 1.3.5 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  output_dir="${args[--output]:-${ini[output_dir]:-${XDG_PICTURES_DIR:-$HOME/Pictures}/Screenshots}}"
  filename_pattern="${args[--filename]:-${ini[filename_pattern]:-%Y%m%d%H%M%S.png}}"
  filename="$(date +"$filename_pattern")"
  filepath="$output_dir/$filename"
  mkdir -p "$output_dir"

  cmd="grim"

  pointer_default="${ini[pointer_default]:-false}"
  pointer_enabled=false
  if [[ $pointer_default == true ]] || [[ ${args[--pointer]} ]]; then
    pointer_enabled=true
  fi

  if [[ $pointer_enabled == true ]]; then
    cmd="$cmd -c"
  fi

  copy_enabled=true
  if [[ ${args[--no-copy]} ]]; then
    copy_enabled=false
  fi
  window_capture=false
  if [[ ${args[--window]} ]]; then
    window_capture=true
  fi
  if [[ $window_capture == true ]]; then
    geometry=$(mmsg -x | awk '/x / {x=$3} /y / {y=$3} /width / {w=$3} /height / {h=$3} END {print x","y" "w"x"h}')
    if [[ -z "$geometry" ]]; then
      echo "Error: No active window found or mmsg failed." >&2
      exit 1
    fi
    cmd="$cmd -g \"$geometry\""
  elif [[ ${args[--geometry]} ]]; then
    cmd="$cmd -g \"${args[--geometry]}\""
  elif [[ ${args[--region]} ]]; then
    cmd="$cmd -g \"\$(slurp -d)\""
  fi

  cmd="$cmd \"$filepath\""

  if [[ ${args[--freeze]} ]]; then
    cmd="still -c '$cmd'"
  fi
  if [[ ${args[--annotate]} ]]; then
    cmd="$cmd && satty --filename \"$filepath\" --output-filename \"$filepath\" --actions-on-enter save-to-file --early-exit --disable-notifications"
  fi
  eval "$cmd"
  if [[ $copy_enabled == true ]]; then
    wl-copy < "$filepath"
    message="Image saved in <i>${filepath}</i> and copied to the clipboard."
  else
    message="Image saved in <i>${filepath}</i>."
  fi
  notify-send "Screenshot saved" "${message}" -i "${filepath}" -a mshot

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
mshot_usage() {
  printf "mshot - Mango shot cli tool\n\n"

  printf "%s\n" "Usage:"
  printf "  mshot [OPTIONS]\n"
  printf "  mshot --help | -h\n"
  printf "  mshot --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--region, -r"
    printf "    Take screenshot of selected region (interactive selection)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--geometry, -g SPEC"
    printf "    Capture region with direct geometry in \"x,y wxh\" format\n"
    echo

    # :flag.usage
    printf "  %s\n" "--pointer, -p"
    printf "    Include pointer in screenshot\n"
    echo

    # :flag.usage
    printf "  %s\n" "--output, -o DIRECTORY"
    printf "    Output directory for screenshot\n"
    echo

    # :flag.usage
    printf "  %s\n" "--filename, -f NAME"
    printf "    Output filename for screenshot\n"
    echo

    # :flag.usage
    printf "  %s\n" "--annotate, -a"
    printf "    Annotate the screenshot with Satty\n"
    echo

    # :flag.usage
    printf "  %s\n" "--window, -w"
    printf "    Capture screenshot of the active window\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-copy"
    printf "    Skip copying screenshot to clipboard\n"
    echo

    # :flag.usage
    printf "  %s\n" "--freeze, -F"
    printf "    Freeze the screen before taking screenshot\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/ini.sh
ini_load() {
  unset ini
  declare -gA ini

  local ini_file="$1"

  local section=""
  local key=""
  local value=""
  local section_regex="^\[(.+)\]"
  local key_regex="^([^ =]+) *= *(.*) *$"
  local comment_regex="^;"

  while IFS= read -r line; do
    if [[ $line =~ $comment_regex ]]; then
      continue
    elif [[ $line =~ $section_regex ]]; then
      section="${BASH_REMATCH[1]}."
    elif [[ $line =~ $key_regex ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      [[ $value == *\$* ]] && eval "value=\"$value\""
      ini["${section}${key}"]="$value"
    fi
  done <"$ini_file"
}

ini_save() {
  declare -gA ini

  local ini_file="$1"

  local current_section=""
  local has_free_keys=false

  rm -f "$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] && continue
    has_free_keys=true
    value="${ini[$key]}"
    echo "$key = $value" >>"$ini_file"
  done

  [[ "${has_free_keys}" == "true" ]] && echo >>"$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] || continue
    value="${ini[$key]}"
    IFS="." read -r section_name key_name <<<"$key"

    if [[ "$current_section" != "$section_name" ]]; then
      [[ $current_section ]] && echo >>"$ini_file"
      echo "[$section_name]" >>"$ini_file"
      current_section="$section_name"
    fi

    echo "$key_name = $value" >>"$ini_file"
  done
}

ini_show() {
  declare -gA ini

  for key in $(ini_keys); do
    echo "$key = ${ini[$key]}"
  done
}

ini_keys() {
  declare -gA ini

  local keys=("${!ini[@]}")
  for a in "${keys[@]}"; do echo "$a"; done | sort
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        mshot_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --region | -r)

        # :flag.case_no_arg
        args['--region']=1
        shift
        ;;

      # :flag.case
      --geometry | -g)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--geometry']="$2"
          shift
          shift
        else
          printf "%s\n" "--geometry requires an argument: --geometry, -g SPEC" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pointer | -p)

        # :flag.case_no_arg
        args['--pointer']=1
        shift
        ;;

      # :flag.case
      --output | -o)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--output']="$2"
          shift
          shift
        else
          printf "%s\n" "--output requires an argument: --output, -o DIRECTORY" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --filename | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--filename']="$2"
          shift
          shift
        else
          printf "%s\n" "--filename requires an argument: --filename, -f NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --annotate | -a)

        # :flag.case_no_arg
        args['--annotate']=1
        shift
        ;;

      # :flag.case
      --window | -w)

        # :flag.case_no_arg
        args['--window']=1
        shift
        ;;

      # :flag.case
      --no-copy)

        # :flag.case_no_arg
        args['--no-copy']=1
        shift
        ;;

      # :flag.case
      --freeze | -F)

        # :flag.case_no_arg
        args['--freeze']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

  # src/initialize.sh
  config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/msnap"
  config_file="$config_dir/mshot.conf"
  if [[ ! -f "$config_file" ]]; then
    mkdir -p "$config_dir"
    cp "./mshot.conf" "$config_file"
  fi
  CONFIG_FILE="$config_file"
  ini_load "$config_file"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
